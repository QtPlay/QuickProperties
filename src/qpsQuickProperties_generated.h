// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_QPSQUICKPROPERTIES_QPS_DAO_H_
#define FLATBUFFERS_GENERATED_QPSQUICKPROPERTIES_QPS_DAO_H_

#include "flatbuffers/flatbuffers.h"


namespace qps {
namespace dao {

struct TimeValue;
struct TimeValueMap;
struct QuickProperties;

MANUALLY_ALIGNED_STRUCT(8) TimeValue FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t t_;
  double v_;

 public:
  TimeValue(uint64_t _t, double _v)
    : t_(flatbuffers::EndianScalar(_t)), v_(flatbuffers::EndianScalar(_v)) { }

  uint64_t t() const { return flatbuffers::EndianScalar(t_); }
  double v() const { return flatbuffers::EndianScalar(v_); }
};
STRUCT_END(TimeValue, 16);

struct TimeValueMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_VALUECOUNT = 6,
    VT_DATA = 8,
  };
  int32_t id() const { return GetField<int32_t>(VT_ID, 0); }
  bool KeyCompareLessThan(const TimeValueMap *o) const { return id() < o->id(); }
  int KeyCompareWithValue(int32_t val) const { return id() < val ? -1 : id() > val; }
  int32_t valueCount() const { return GetField<int32_t>(VT_VALUECOUNT, 0); }
  const flatbuffers::Vector<const TimeValue *> *data() const { return GetPointer<const flatbuffers::Vector<const TimeValue *> *>(VT_DATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_VALUECOUNT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct TimeValueMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) { fbb_.AddElement<int32_t>(TimeValueMap::VT_ID, id, 0); }
  void add_valueCount(int32_t valueCount) { fbb_.AddElement<int32_t>(TimeValueMap::VT_VALUECOUNT, valueCount, 0); }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<const TimeValue *>> data) { fbb_.AddOffset(TimeValueMap::VT_DATA, data); }
  TimeValueMapBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TimeValueMapBuilder &operator=(const TimeValueMapBuilder &);
  flatbuffers::Offset<TimeValueMap> Finish() {
    auto o = flatbuffers::Offset<TimeValueMap>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<TimeValueMap> CreateTimeValueMap(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t id = 0,
   int32_t valueCount = 0,
   flatbuffers::Offset<flatbuffers::Vector<const TimeValue *>> data = 0) {
  TimeValueMapBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_valueCount(valueCount);
  builder_.add_id(id);
  return builder_.Finish();
}

struct QuickProperties FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMEVALUEMAPS = 4,
  };
  const flatbuffers::Vector<flatbuffers::Offset<TimeValueMap>> *timeValueMaps() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TimeValueMap>> *>(VT_TIMEVALUEMAPS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TIMEVALUEMAPS) &&
           verifier.Verify(timeValueMaps()) &&
           verifier.VerifyVectorOfTables(timeValueMaps()) &&
           verifier.EndTable();
  }
};

struct QuickPropertiesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timeValueMaps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TimeValueMap>>> timeValueMaps) { fbb_.AddOffset(QuickProperties::VT_TIMEVALUEMAPS, timeValueMaps); }
  QuickPropertiesBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  QuickPropertiesBuilder &operator=(const QuickPropertiesBuilder &);
  flatbuffers::Offset<QuickProperties> Finish() {
    auto o = flatbuffers::Offset<QuickProperties>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<QuickProperties> CreateQuickProperties(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TimeValueMap>>> timeValueMaps = 0) {
  QuickPropertiesBuilder builder_(_fbb);
  builder_.add_timeValueMaps(timeValueMaps);
  return builder_.Finish();
}

inline const qps::dao::QuickProperties *GetQuickProperties(const void *buf) { return flatbuffers::GetRoot<qps::dao::QuickProperties>(buf); }

inline bool VerifyQuickPropertiesBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<qps::dao::QuickProperties>(); }

inline void FinishQuickPropertiesBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<qps::dao::QuickProperties> root) { fbb.Finish(root); }

}  // namespace dao
}  // namespace qps

#endif  // FLATBUFFERS_GENERATED_QPSQUICKPROPERTIES_QPS_DAO_H_

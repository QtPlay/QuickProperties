
/*! \mainpage QuickProperties Manual

  \tableofcontents

\section qpintro Overview 

QuickProperties is a C++/QML library designed to ease edition and management of QObject static and dynamic properties. While being developed with properties edition in mind, QuickProperties also contains simple UI components such as modal/modeless dialogs and a hideable panel that could be reused for fast QML applications prototyping.

\image html qps-overview.png

QuickProperties focus on providing a consistent data model based on and around QObject which is the simplest way of exposing data in advanced QML UIs. QuickProperties (QPS) main concepts are:
\li <b>Properties:</b> properties are a set of standard Qt static and dynamic in a QObject. 
\li <b>Timed properties:</b> extend previous concept with date/time support; all property elements values could be changed and retrieved over time allowing the user to display a time graph of values for specific properties.
\li <b>DataSource:</b> either a synchronous or asynchronous source of data for timed properties (actually, an XML or CSV file, or a more advanced wrapper such as in to the Y!F  HTTP stock sample).
\li <b>Qt Item Model interface:</b> QPS expose QObject properties in a standard Qt Item Model interface, allowing visualization and edition of properties directly in existing QML components.

Jump to next sections for more details:
\tableofcontents
- \ref qpinstall
- \ref qpui
	- \ref qpdialogs
	- \ref qppanels
- \ref qpproperties
	- \ref qpcreating
	- \ref qpdynamic
	- \ref qpstatic
	- \ref qpedit
	- \ref qplimits
- \ref qpsamples

\section qpinstall Installation 
	
Clone: https://github.com/cneben/QuickProperties/

Qmake configuration, assuming that QUICKPROPERTIESDIR point to your local installation of QuickProperties:
\code
CONFIG += qt thread c++11
QT     += widgets core gui qml quick quickwidgets

# Set QUICKPROPERTIESDIR env var pointing to your current QuickProperties root directory
INCLUDEPATH     += $(QUICKPROPERTIESDIR)/src 
QMAKE_LIBDIR    += $(QUICKPROPERTIESDIR)/build

RESOURCES += 	$(QUICKPROPERTIESDIR)/src/QuickProperties.qrc   

# Release configuration
CONFIG(release, debug|release) {
    linux-g++*: LIBS	+= -L$(QUICKPROPERTIESDIR)/build/ -lquickproperties
    android:    LIBS	+= -L$(QUICKPROPERTIESDIR)/build/ -lquickproperties
    win32-msvc*:      PRE_TARGETDEPS += $(QUICKPROPERTIESDIR)/build/quickqanava.lib
    win32-msvc*:      LIBS	+=  $(QUICKPROPERTIESDIR)/build/quickproperties.lib 
    win32-g++*: LIBS	+= --L$(QUICKPROPERTIESDIR)/build/ -lquickproperties
} 

# Debug configuration
CONFIG(debug, debug|release) {
    linux-g++*: LIBS	+= -L$(QUICKPROPERTIESDIR)/QuickProperties/build/ -lquickpropertiesd 
    android:    LIBS	+= -L$(QUICKPROPERTIESDIR)/QuickProperties/build/ -lquickpropertiesd 
    win32-msvc*:     PRE_TARGETDEPS += $(QUICKPROPERTIESDIR)/QuickProperties/build/quickpropertiesd.lib 
    win32-msvc*:     LIBS	+=  $(QUICKPROPERTIESDIR)/build/quickpropertiesd.lib 
    win32-g++*: LIBS	+= -L$(QUICKPROPERTIESDIR)/build/ -lquickpropertiesd 
}
\endcode

On the QML side, just add 'QuickProperties.qrc' resources file from \c QuickProperties\src directory to your project resources and import all QuickProperties components with the following statement: 
\code
import "qrc:/QuickProperties"
\endcode

A "qpsTranslator" context property must be initialized in the QML engine root context, even if internationalization is not required in your application.
\code
    qps::Translator* translator = new qps::Translator( application, this );
    translator->installTranslation( "fr", "quickproperties", "-", "../../src" );	// Do not load any translator if internationalization is not required
    rootContext( )->setContextProperty( "qpsTranslator", translator );
\endcode

QML types corresponding to QuickProperties C++ objects should also be registered in the QML engine, a standard initialization should look like:
\code
    qmlRegisterType< qps::Properties >( "QuickProperties", 1, 0, "QpsProperties");
    qmlRegisterType< qps::Limit >( "QuickProperties", 1, 0, "QpsLimit");
    qmlRegisterType< qps::StringLimit >( "QuickProperties", 1, 0, "QpsStringLimit");
    qmlRegisterType< qps::RealLimit >( "QuickProperties", 1, 0, "QpsRealLimit");
    qmlRegisterType< qps::IntLimit >( "QuickProperties", 1, 0, "QpsIntLimit");
\endcode

\section qpui User interface components

While QuickProperties is not a general UI component library, some components built for the property editor are available to developers  for fast application prototyping: 
\li QpsModalDialog: \copybrief QpsModalDialog
\li QpsModelessDialog: \copybrief QpsModelessDialog
\li QpsHideablePanel: \copybrief QpsHideablePanel

\image html quickproperties_sample-propsdialogs.png
 
\subsection qpdialogs Modal and modeless dialogs

Main difference between Qt and QuickProperties dialogs is that Qps dialogs don't relies on platform specific dialogs, they are regular QML items that will kept the same look and feel over all platforms (without relying on QML Window support). Qps dialogs have simple styling options that allow fast prototyping with little efforts because layout is not done "top-down" like in QML but "bottom-up", ie  dialogs will fit to their content and adapt to a panel being collapsed by user for example (see QpsHideablePanel).

\sa QpsModelessDialog
\sa QpsModalDialog

\subsection qppanels Dialogs panels

\sa QpsHideablePanel

\section qpproperties Managing properties 

You should be familiar with the Qt property system before reading this document:
    \li Qt property system: http://doc.qt.io/qt-5/properties.html
    \li Qt dynamic properties documentation: http://doc.qt.io/qt-5/qobject.html#dynamic-properties

Basically, a qps::Properties object is a regular QObject (or QtObject from a QML point of view) embedding standard Qt properties defined with the Q_PROPERTY macro or the QObject::setProperty / QObject::property methods. QuickProperties add an "abstract item model" (see http://doc.qt.io/qt-5/model-view-programming.html) on top of QObject to allow edition of property through  an MVC pattern. In the future, QuickProperties should be able to track changes of properties value over time with the qps::TimedProperties class.

Properties are managed with the following QuickProperties classes:
    \li \c qps::Properties: \copybrief qps::Properties
    \li \c qps::TimedProperties: \copybrief qps::TimedProperties
    \li \c qps::PropertiesList: \copybrief qps::PropertiesList

QML components are more specifically designed to visualize the content of a qps::Properties object and edit its internal "property" elements:
	\li \c QpsPropertiesEditor: \copybrief QpsPropertiesEditor
	\li \c QpsPropertyCreator: \copybrief QpsPropertyCreator

	\image html 20150719_NP_Quick_Properties.png

\subsection qpcreating Creating properties

An empty qps::Properties object can be created with new and no arguments:
\code
    Properties* p1 = new qps::Properties( );
    // Or with timed values:
	//Properties* p1 = new qps::TimedProperties( );
    qDebug( ) << *p1;
\endcode
	results in the following output:
\code
Properties: ""
First date time stamp=	QDateTime( Qt::TimeSpec(LocalTime))
Last date time stamp=	QDateTime( Qt::TimeSpec(LocalTime))
objectName=""(current) 
no timed values.
label=""(current) 
no timed values.
current=""(current) 
no timed values.
first=""(current) 
no timed values.
last=""(current) 
no timed values.
timeValue="1"(current) 
no timed values.
propertiesModel=""(current) 
no timed values.
\endcode

\c objectName is a QObject defined property and will appears whatever property where defined by the user in subclass. The following properties from 'label' to 'propertiesModel' are defined by qps::Properties, and are shown by default in QML properties view. Theses "systems" properties could be be hidden in the corresponding model using qps::Properties::hideStaticProperties() method.

\subsection qpdynamic Adding a dynamic property

A dynamic property could be added with the standard QObject interface QObject::setProperty(), or using qps::Properties::addProperties() method. Once created, the "current" value can be set using QObject::setProperty() or qps::Properties::setProperty() methods:
\code
    Properties* p1 = new qps::Properties( );
    p1->addProperty( "intProperty", QVariant::fromValue< int >( 40 ) );
    p1->setProperty( "intProperty", 42 );
    qDebug( ) << *p1;
\endcode
\code
"intProperty"="40"(current) 
\endcode

If timed values support is necessary, create a qps::TimedProperties object instead of qps::Properties and specify a QDateTime time stamp in qps::TimedProperties::setProperty() method (QObject interface could not be used in that specific case or time values will not been taken into account):
\code
    Properties* p1 = new qps::TimedProperties( );
    p1->addProperty( "intProperty", QVariant::fromValue< int >( 40 ) );
    QDateTime current = QDateTime::currentDateTimeUtc( );
    p1->setProperty( "intProperty", current, 41 );
    p1->setProperty( "intProperty", current.addMSecs( 1000 ), 42 );
    qDebug( ) << *p1;
\endcode
\code
"intProperty"="40"(current) 
	QDateTime(2015-07-29 16:05:05.363 UTC Qt::TimeSpec(UTC)):QVariant(int, 41)
	QDateTime(2015-07-29 16:05:06.363 UTC Qt::TimeSpec(UTC)):QVariant(int, 42)
\endcode

Dynamic enumerations are supported with the qps::Properties::addEnumProperty(), qps::Properties::isEnum() and qps::Properties::getEnumValueLabels() methods. To add a dynamic property enum based on Qt Qt::PenStyle, use the following code:
\code
qps::Properties properties = new qps::Properties();
QStringList lineStyles; lineStyles << "No line" << "Solid line" << "Dash line" << "Dot line" << "Dash Dot line" << "Dash Dot Dot line";
properties->addEnumProperty( "Pen Style property", QVariant::fromValue< Qt::PenStyle >( Qt::SolidLine ), lineStyles );
\endcode

\subsection qpstatic Managing static property elements

Static "property element" could be added with the standard Q_PROPERTY QObject mechanism, no specific calls to QuickProperties are necessary
\code
class MyProperties : public qps::Properties
{
    Q_OBJECT
public:
    MyProperties( QObject* parent = 0 ) : qps::Properties( parent, "myProperties" ), _doubleProperty( 0. ) { }
    virtual ~MyProperties( ) { }
private:
    Q_DISABLE_COPY( MyProperties )

    // User defined static double property
public:
    Q_PROPERTY( double  doubleProperty READ getDoubleProperty WRITE setDoubleProperty NOTIFY doublePropertyChanged )
    Q_INVOKABLE double  getDoubleProperty( ) const { return _doubleProperty; }
    Q_INVOKABLE void    setDoubleProperty( double dp ) { _doubleProperty = dp; emit doublePropertyChanged( ); }
signals:
    void        doublePropertyChanged( );
protected:
    double      _doubleProperty;
};
\endcode

\code
MyProperties* mp = new MyProperties( this );
qDebug( ) << *mp;
\endcode
Result in the following output:
\code
doubleProperty="0"(current) 
no timed values.
\endcode

The QML version of this code is much simpler, properties are defined as with regular QtObject components (don't forget to call qmlRegisterType< qps::Properties >( "QuickProperties", 1, 0, "QpsProperties")) :
\code
QpsProperties {
  property real doubleProperty: 0.
}
\endcode

Once defined, properties could be serialized to any XML stream and reused later with qps::Properties::serializeOut() and qps::Properties::serializeIn().

\note 20151022: automatic serialization to QSetting is planned for a next release.

\subsection qpedit Viewing and editing properties

Once defined, properties could be edited using the QpsPropertiesEditor, or just viewed with QpsPropertiesView, and used with regular binding to control other parts of your application. Using properties edition for building a simple style editor for a Rectangle component colors could be done easily in the following way:

\code
QpsProperties {
  id: rectangleStyle
  property color  color: "blue"
  property color  borderColor: "violet"
}
Rectangle {	// Our "styled" rectangle
  // x, y, width, height init...
  color:        rectangleStyle.color				// Bind Rectangle properties to our QpsProperties properties
  border.color: rectangleStyle.borderColor
  border.width: 1
}
Rectangle {
  // x: 15; y: 15; width: 250; height: 300	// Editor position init
  color: "lightblue"; border.width: 2; border.color: "black"
  QpsPropertiesEditor {
    anchors.fill: parent; anchors.margins: 5
    properties: rectangleStyle      // QpsProperties is also an Qt item model, it could be used as a 'model' for any QML view control
  }
}
\endcode

With more properties being defined in \c rectangleStyle, the result would look like:
\image html quickproperties_QpsPropertiesEditor-QML.png

Using QpsModelessDialog together with a QpsPropertyCreator hideable panel, you get a more advanced control:
\image html quickproperties_QpsPropertiesEditor-Cpp.png

\subsection qplimits Fine control over properties edition

Once exposed through a qps::Properties model, edition of specific "property elements" could be fine tuned  to restrict how  property should be modified by an end user. For example, in the previous Rectangle styling sample, the user should not be allowed to set a zero width or height. These limitations could be specified in declarative QML or C++ with the following classes (and their corresponding QML components QpsStringLimit, QpsRealLimit and QpsIntLimit):
\li qps::StringLimit:  \copybrief qps::StringLimit
\li qps::RealLimit:  \copybrief qps::RealLimit
\li qps::IntLimit: \copybrief qps::IntLimit

Limits could be defined in plain declarative QML code (apply to corresponding Rectangle properties):
\code
QpsProperties {
    property string content: "Rectangle content string"
    QpsStringLimit { target: "content"; maxChars: 40 }		// String will not exceed 40 characters in QpsPropertiesEditor

    property real   radius: 5
    QpsRealLimit { target: "borderWidth"; min: 0.; max: 5.; stepSize:0.2 }

    property int    borderWidth: 3
    QpsIntLimit { target: "borderWidth"; min: 1; max: 15 }
}
\endcode

In C++, limits could be declared in the following way (destruction via the parent QObject):
\code
// In .h
class MyProperties : public qps::Properties {
    //...
public:
	Q_PROPERTY( QString content READ getContent WRITE setContent NOTIFY contentChanged );
	Q_PROPERTY( double radius READ getRadius WRITE setRadius NOTIFY radiusChanged );	
	Q_PROPERTY( int borderWidth READ getBorderWidth WRITE setBorderWidth NOTIFY borderWidthChanged );
	//...
};
// In .cpp
MyProperties( QObject* parent = 0 ) :
    qps::Properties( parent ) //, ...
{
    new qps::StringLimit( this, "content", 40 );
    new qps::RealLimit( this, "radius", 0., 5., 0.2 );
    new qps::IntLimit( this, "borderWidth", 1, 15 ); // Will be destroyed from QObject parent destructor
}
\endcode
With all properties referenced in 'target' parameter previously declared with Q_PROPERTY macros.

\note 20151022: there is currently no support for limits over QDateTime properties. 

\section timegraph Time graphs

\image html timegraph.png

\section qpsamples Samples

Sample \c propsdialogs:

https://github.com/cneben/QuickProperties/tree/master/tests/propsdialogs

\image html quickproperties_sample-propsdialogs.png

Sample \c propsedit: demonstrate how to use QuickProperties as a basic style editor for visual component from both C++ and QML.

https://github.com/cneben/QuickProperties/tree/master/tests/propsedit

\image html quickproperties_sample-propsedit.png

Sample \c propsgraph:

Note 20151022: Timed properties graph display is currently under intensive rewrite, the old sample is still compiling:

\image html quickproperties_sample-propsgraph.png


*/